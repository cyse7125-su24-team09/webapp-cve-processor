package cve

import (
	"cve-processor/config"
	"cve-processor/internal/utils"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
)

func ProcessRecords(config *config.Config, rootDir string) error {
	// Initialize kafka producer
	producer, err := utils.NewKafkaProducer(config)
	if err != nil {
		return err
	}
	defer producer.Close()

	err = filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && filepath.Ext(path) == ".json" {
			baseName := filepath.Base(path)
			if baseName == "delta.json" || baseName == "deltaLog.json" {
				return nil
			}
			err := processRecord(path, producer)
			if err != nil {
				log.Printf("Error processing CVE record %s: %v", path, err)
			}
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("error processing CVE records %s: %v", rootDir, err)
	}
	return nil
}

func processRecord(path string, producer *utils.KafkaProducer) error {
	jsonData, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read record file: %w", err)
	}

	var record CVERecordData
	if err := json.Unmarshal([]byte(jsonData), &record); err != nil {
		return fmt.Errorf("failed to parse record: %w", err)
	}

	// Produce the message to Kafka
	partition, offset, err := producer.WriteMessage(jsonData)
	if err != nil {
		return fmt.Errorf("failed to produce message to Kafka: %w", err)
	}
	log.Printf("Succesfully produced message to Kafka: CVE ID is %s, partion is %v, and offset is %v", record.CVEMetadata.CVEID, partition, offset)

	return nil
}
